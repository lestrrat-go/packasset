package packasset

import (
	"bytes"
	"compress/flate"
	"fmt"
	"go/format"
	"io"
	"os"
	"sort"
	"strconv"

	"github.com/pkg/errors"
)

func NewGenerator(options ...Option) *Generator {
	var packageName = "main"
	var files []string
	for _, o := range options {
		switch o.Name() {
		case "package_name":
			packageName = o.Value().(string)
		case "files":
			files = o.Value().([]string)
		}
	}

	return &Generator{
		packageName: packageName,
		files:       files,
	}
}

func (g *Generator) Generate() ([]byte, error) {
	var buf bytes.Buffer
	fmt.Fprintf(&buf, `// Automatically generated by packasset. DO NOT EDIT`)
	fmt.Fprintf(&buf, "\n\npackage %s", g.packageName)

	fmt.Fprintf(&buf, "\n\nimport (")
	for _, n := range []string{"bytes", "compress/flate", "io", "reflect", "strings", "unsafe"} {
		fmt.Fprintf(&buf, "\n%s", strconv.Quote(n))
	}
	fmt.Fprintf(&buf, "\n")
	for _, n := range []string{"github.com/pkg/errors"} {
		fmt.Fprintf(&buf, "\n%s", strconv.Quote(n))
	}
	fmt.Fprintf(&buf, "\n)")

	fmt.Fprintf(&buf, "\n\ntype asset struct {")
	fmt.Fprintf(&buf, "\ncached []byte")
	fmt.Fprintf(&buf, "\ndata string")
	fmt.Fprintf(&buf, "\nname string")
	fmt.Fprintf(&buf, "\n}")

	sort.Strings(g.files)
	fmt.Fprintf(&buf, "\n\nvar _assets = map[string]*asset{")
	for _, file := range g.files {
		fmt.Fprintf(&buf, "\n%s: {", strconv.Quote(file))
		fmt.Fprintf(&buf, "\nname: %s,", strconv.Quote(file))
		fmt.Fprintf(&buf, "\ndata: \"")
		content, err := g.fileContent(file)
		if err != nil {
			return nil, errors.Wrapf(err, `generator: failed to generate file content for %s`, file)
		}

		for _, b := range content {
			fmt.Fprintf(&buf, "\\x%02x", b)
		}
		fmt.Fprintf(&buf, "\",")
		fmt.Fprintf(&buf, "\n},")
	}
	fmt.Fprintf(&buf, "\n}")

	fmt.Fprintf(&buf, "\n\nfunc toBytes(s string) []byte {")
	fmt.Fprintf(&buf, "\nvar empty [0]byte")
	fmt.Fprintf(&buf, "\nsx := (*reflect.StringHeader)(unsafe.Pointer(&s))")
	fmt.Fprintf(&buf, "\nb := empty[:]")
	fmt.Fprintf(&buf, "\nbx := (*reflect.SliceHeader)(unsafe.Pointer(&b))")
	fmt.Fprintf(&buf, "\nbx.Data = sx.Data")
	fmt.Fprintf(&buf, "\nbx.Len = len(s)")
	fmt.Fprintf(&buf, "\nbx.Cap = bx.Len")
	fmt.Fprintf(&buf, "\nreturn b")
	fmt.Fprintf(&buf, "\n}")

	fmt.Fprintf(&buf, "\n\n// Asset")
	fmt.Fprintf(&buf, "\nfunc Asset(name string) ([]byte, error) {")
	fmt.Fprintf(&buf, "\na, ok := _assets[name]")
	fmt.Fprintf(&buf, "\nif !ok {")
	fmt.Fprintf(&buf, "\nreturn nil, errors.Errorf(`asset: asset %%s not found`, name)")
	fmt.Fprintf(&buf, "\n}")
	fmt.Fprintf(&buf, "\nif b := a.cached; b != nil {")
	fmt.Fprintf(&buf, "\nreturn b, nil")
	fmt.Fprintf(&buf, "\n}")
	fmt.Fprintf(&buf, "\nvar buf bytes.Buffer")
	fmt.Fprintf(&buf, "\nif _, err := io.Copy(&buf, flate.NewReader(strings.NewReader(a.data))); err != nil {")
	fmt.Fprintf(&buf, "\nreturn nil, errors.Wrap(err, \"failed to deflate content\")")
	fmt.Fprintf(&buf, "\n}")
	fmt.Fprintf(&buf, "\na.cached = buf.Bytes()")
	fmt.Fprintf(&buf, "\nreturn buf.Bytes(), nil")
	fmt.Fprintf(&buf, "\n}")

	return format.Source(buf.Bytes())
}

func (g *Generator) fileContent(fn string) ([]byte, error) {
	var buf bytes.Buffer
	out, err := flate.NewWriter(&buf, flate.BestCompression)
	if err != nil {
		return nil, errors.Wrap(err, `generator: failed to create flate writer`)
	}

	f, err := os.Open(fn)
	if err != nil {
		return nil, errors.Wrap(err, `generator: failed to open file`)
	}
	defer f.Close()

	if _, err := io.Copy(out, f); err != nil {
		return nil, errors.Wrap(err, `generator: failed to write file content`)
	}

	if err := out.Close(); err != nil {
		return nil, errors.Wrap(err, `generator: failed to deflate file content`)
	}

	return buf.Bytes(), nil
}
